---
title: Module Design Pattern
created: July 3th, 2024
updated: July 5th, 2024
description: 
  The Module Design Pattern encapsulates related state and logic within a module.
  If the module has any exports, named or default, then those exports form the
  public interface of the module, and the remaining non-exported code forms the
  private interface, which is only accessible within the module. External code 
  can interact with the module's encapsulated code through the controlled 
  exported public interface. 

tags: ['javascript']
categories: ['design patterns', 'oop']
---


<script lang="ts">
	import Link from '$lib/elements/Link.svelte';

    let publicVariable = 10
  function publicFunction() {
    console.log("Original console log message at time of closure")
    console.log("Value of 'publicVariable' at time of closure:", publicVariable)
  }

  function privateFunction() {
    publicFunction()
  }
  let textAreaValue = "This is a textarea";
</script>

<section>

  ## Explanation

  <br/>

  **NOTE**
  > In this article, the term ***encapsulate*** is used to refer to the 
  organization of code under a namespace. It does **not** mean making code private. 

  <br/>

  The Module Design Pattern encapsulates related state and logic within a module.
  If the module has any exports, named or default, then those exports form the
  public interface of the module, and the remaining non-exported code forms the
  private interface, which is only accessible within the module. External code 
  can interact with the module's encapsulated code through the controlled, 
  exported public interface. 

  The reason the module design pattern in JavaScript is able to provide a public 
  and private interface is due to the way the JavaScript module system works. 
  The import/export mechanism allows for exposing only selected parts of the module 
  for import by other modules, creating a public interface while the rest of the 
  module remains private.

  When a module is imported, all of its top level code is executed. During this phase,
  the module's private and public interfaces are defined. If the exported public
  interface contains functions, then a <Link href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" linkText="closure" />
  gets created that retains access to the private interface even after the module's 
  initial execution on first import.



</section>

<section>
	<Link 
    href="https://en.wikipedia.org/wiki/Modular_programming" 
    linkText="Wikipedia article" 
    block={true} /> says:

    > Modular programming is a software design technique that emphasizes separating the functionality of a 
    program into independent, interchangeable modules, such that each contains everything necessary to 
    execute only one aspect of the desired functionality.

    > A module interface expresses the elements that are provided and required by the module. The elements 
    defined in the interface are detectable by other modules. The implementation contains the working code 
    that corresponds to the elements declared in the interface.

</section>

<section>

  ## Analogy

  We can think of a vending machine as a module that encapsulates a variety of snacks and provides a public 
  interface and a private interface. To select and pay for snacks, we interact with the keypads and the 
  payment slot, which can be thought of as the public interface. On the other hand, the private interface 
  is only available to the vending machine for dispensing and replenishing snacks.

</section>

<section>

  ## Code Example

  In this code example, we have a module named `bankAccount.mjs`, and the module exports a default 
  `bankAccount`,  object that forms the **public interface** of the module. 

  The encapsulated **state** includes `accountTypes` and `accountBalances`, and the encapsulated 
  **logic** includes the functions `calculateInterestPrivate`, `getAccountTypes`, `getAccountBalance`, 
  `deposit`, `withdraw`, and `calculateInterest`.

  Notice that the `calculateInterest` function in the public interface invokes the `calculateInterestPrivate` 
  function from the private interface. When using the module design pattern, this is a way to hide 
  implementation details of the module from external users while still making the functionality of the 
  private interface available through the public interface.

  ```js
    // bankAccount.mjs

    // private interface
    let accountTypes = ['checking', 'savings'];
    let accountBalances = {
      checking: 100,
      savings: 50
    } 

    // private interface
    function calculateInterestPrivate(amount, timePeriod) {
      // private interest rate calculation implementation
    }


    // public interface
    const bankAccount = {
      getAccountTypes: function() { 
        return accountTypes
      },

      getAccountBalance: function(accountType){
        return accountBalances[accountType]
      },


      deposit: function(amount, accountType){
        accountBalances[accountType] += amount;
      },

      withdraw: function(amount, accountType){
        if(accountTypes.includes(accountType)){
          if(accountBalances[accountType] >= amount){
            accountBalances[accountType] -= amount;
            console.log(`Withdrew ${amount} from ${accountType}`);
          }
          else {
            console.log(`You don't have enough money in ${accountType}`);
            console.log(`Your balance is ${accountBalances[accountType]}`);
          }
        } else {
          console.log(`Invalid account type`);
          console.log(`Valid account types are ${accountTypes}`);
        }
      },

      calculateInterest: function(amount, timePeriod){
        calculateInterestPrivate(amount, timePeriod)
      }
    };

    export default bankAccount
  ```


  <br>

  #### Advantages

  - **Encapsulation**: The ability to organize related code into one file improves the readability of that code and the overall codebase.

  - **Public & Private interfaces**: The ability to hide implementation details and expose only certain parts is beneficial.

  - **Namespace management**: When importing a module, the import name given to the module becomes the namespace by which the module’s 
  functionality is accessed. This namespace, used as a prefix before identifiers of the imported module, avoids name collisions with 
  identifiers of the same name in other modules.

  - **Ability to Update Public Members**: Public variables and functions on the exported object can be reassigned and redefined by external 
  module users to make it fit their use cases. It’s important to note that these updates do affect the original module and therefore any 
  other modules that import it.

  <br>


  #### Disadvantages
  
  - **Visibility Change Overhead**: If you change the visibility of a member (state or logic) from private to public or vice versa, you need to:  
    - Update all instances of where that member was accessed, as the way to access the member will change based on its visibility.

    - If adding a private member to the public interface, we need to remove it from the private interface scope and add it to the public
    interface scope, and vice versa.


    - **No Access To Private Members**: Depending on the context, you might be working with an external module whose source code you can’t 
    modify. Private members become a limitation in such scenarios because if you want to add additional functionality to the module, you won’t 
    be able to access the private members.

    - **Limitation in Testing Granularity**: Since only the public interface is exposed, testing of private members is only possible  
    through unit testing of the public members. 


</section>

<section>

  ## Variations 
  ### The Revealing Module Design Pattern

  The Revealing Module Design Pattern variation differs from the main design pattern by defining all 
  the state and logic in the private interface and exporting only references to them in the public 
  interface.

  #### Code Example

  ```js
    // bankAccount.mjs

    // private interface
    let accountTypes = ['checking', 'savings'];
    let accountBalances = {
      checking: 100,
      savings: 50
    } 

    // private interface
    function calculateInterestPrivate(amount, timePeriod) {
      // private interest rate calculation implementation
    }

    // private interface
    function getAccountTypes() { 
        return accountTypes
    }
    // private interface
    function getAccountBalance(accountType){
        return accountBalances[accountType]
    }
    // private interface
    function deposit(amount, accountType){
        accountBalances[accountType] += amount;
    }
    // private interface
    function withdraw(amount, accountType){
      if(accountTypes.includes(accountType)){
        if(accountBalances[accountType] >= amount){
          accountBalances[accountType] -= amount;
          console.log(`Withdrew ${amount} from ${accountType}`);
        }
        else {
          console.log(`You don't have enough money in ${accountType}`);
          console.log(`Your balance is ${accountBalances[accountType]}`);
        }
      } else {
        console.log(`Invalid account type`);
        console.log(`Valid account types are ${accountTypes}`);
      }
    }
    // private interface
    function calculateInterest(amount, timePeriod){
      calculateInterestPrivate(amount, timePeriod)
    }

    // public interface
    export default {
      getAccountTypes,
      getAccountBalance,
      deposit,
      withdraw,
      calculateInterest,
    };
  ```


    <br>

  #### Advantages

  **NOTE:** All the advantages of the original Module Design Pattern apply to the Revealing Module Pattern as well as:

  - **Simplified Visibility Management**: In the Revealing Module Design Pattern, all the state and logic are always defined in the 
  private interface scope, so if you want to expose a private member to the public interface, you simply add it to the returned object 
  (public interface). If you want to make a public member private, you can simply remove it from the returned object or comment it out. 
  This is simpler than the approach in the original Module Design Pattern, where changing the visibility of a member required updating 
  all instances of where that member was accessed.


  <br>

  #### Disadvantages
    
  **NOTE:** Besides "Visibility Change Overhead", all the disadvantages of the original Module Design Pattern apply to The 
  Revealing Module Design Pattern. 

  The reason "Visibility Change Overhead" doesn't apply is because all the state and logic are always defined in the private interface scope. 
  Therefore, its scope always remains private, and accessing it always remains consistent, whether the member is exposed through the public 
  interface or not. But the following disadvantages apply:

  <br/>


  **Disadvantage #1**

  Reassigning a public variable on the public interface externally will only update that variable within the scope of the 
  exported interface object. The reassignment does not reassign the public variable within the `private` scope of the module. 
  Therefore, if any function within the module refers to that variable, it will retain the original value assigned to it due 
  to the closure created at the time of the function's definition, which occurs upon the module’s initial import.
  
  <br/>

  The following code example illustrates this:

  1. We define `publicVariable = 10` within `moduleOne.js`.
  2. We define `publicFunction` within `moduleOne.js` that logs `publicVariable`.
  3. We export `publicVariable` and `publicFunction` as part of the public interface of the module.
  4. Within `moduleTwo.mjs`, we reassign `publicVariable = 88`.
  5. We log `module.publicVariable`, which outputs `88`.
  6. Then, we invoke `moduleOne.publicFunction()`, which outputs `10`.


  ```js
    // moduleOne.mjs

    let publicVariable = 10

    function publicFunction() {
      console.log("publicVariable:", publicVariable)
    }

    export default {
      publicVariable, 
      publicFunction
    }
  ```

  ```js
    // moduleTwo.mjs

    import moduleOne from './moduleOne.mjs';

    // Logs 'publicVariable: 10'
    console.log('publicVariable:', moduleOne.publicVariable);

    // Logs "publicVariable: 10"
    moduleOne.publicFunction();

    moduleOne.publicVariable = 88; // [!code focus:1]

    // Logs "publicVariable: 88"
    console.log('publicVariable:', moduleOne.publicVariable);

    // Still logs "publicVariable: 10"
    // This is because publicFunction within moduleOne.mjs is still 
    // referring to the original value of publicVariable from when the 
    // closure was first created.
    moduleOne.publicFunction(); 
  ```

  <br/>

  Output:
  <img src="/images/blog/patterns/creational/module/disadvantage_1.png" alt="Disadvantage #1" class="w-full">


  <br/>
  <br/>
  <br/>


  **Solution**

  To solve this issue, we can expose a setter function as a member of the public interface that allows us to 
  update the public variable from within the module. This will work because the setter function has access to the
  identifier 'publicVariable' enclosed within the closure.

  ```js
    // moduleOne.mjs

    let publicVariable = 10

    function publicFunction() {
      console.log("publicVariable:", publicVariable)
    }

    // Define a setter for the publicVariable // [!code focus:4]
    function setPublicVariable(value){
      publicVariable = value;
    }

    export default {
      publicVariable, 
      publicFunction,
      // add the setter function to the public interface // [!code focus:1]
      setPublicVariable // [!code focus:1]
    }
  ```

  ```js
    // moduleTwo.mjs

    import moduleOne from './moduleOne.mjs';

    // Logs "publicVariable: 10"
    moduleOne.publicFunction();

    // Use setPublicVariable to set the publicVariable // [!code focus:5] 
    moduleOne.setPublicVariable(88);

    // Logs "publicVariable: 88"
    moduleOne.publicFunction(); 
  ```

  <br/>

  Output:
  <img src="/images/blog/patterns/creational/module/solution_1.png" alt="Disadvantage #1" class="w-full">
  <br/>

  <br>

  ---

  <br>


  ##### Disadvantage #2

  Redefining a function on the public interface externally will only update that function within the local copy of the exported 
  interface object. The redefinition does not redefine the public function within the `private` scope of the imported module. 
  Therefore, if any `private` function within the module references that public function, it will retain the original implementation
  due to the closure created at the time of the private function's definition, which occurs upon the module’s initial import.

  <br/>

  The following code example illustrates this:

  ```js
    // moduleOne.mjs
    
    // Define a private function that references a public function
    function privateFunction() {
      publicFunction();
    }
    
    function publicFunction() {
      console.log("publicFunction: original implementation");
    }
    
    // Call the private function after 3 seconds
    setTimeout(() => {
      console.log('-----------setTimeout-------------');
      privateFunction();
    }, 3000);
    
    export default {
      publicFunction
    };
  ```

  ```js
    // moduleTwo.mjs

    import moduleOne from './moduleOne.mjs';
    
    // logs the original message
    moduleOne.publicFunction();
    
    // Redefine publicFunction
    moduleOne.publicFunction = function () {
      console.log("publicFunction: redefined implementation");
    };
    
    // logs the new message
    moduleOne.publicFunction();
    
    // After two seconds the `setTimeout` function will call the privateFunction
    // which calls publicFunction, which will still log the original message.
    // This is because privateFunction still retains a reference to the original
    // implementation of publicFunction from when the closure was first created.
  ```

  <br/>

  Output:
  <img src="/images/blog/patterns/creational/module/disadvantage_2.png" alt="Disadvantage #2" class="w-full">


  <br/>
  <br/>
  <br/>


  **Solution**

  In this scenario, I can think of one solution, although it is not very practical. The solution involves three steps:
    - Define the public function using a function expression instead of using a function declaration.
    - Define a setter function that assigns the public function identifier to a new function and expose it as a member of the public interface.
    - Define a getter function that returns the public function and expose it as a member on the public interface.


    This approach allows us to assign a new function to the `publicFunction` identifier from within the module. However, 
    it requires using the getter function every time we set a new function so that we can get the new public function.  

  <br>

  The following code example illustrates this:

  ```js
    // moduleOne.mjs
    
    // Define a private function that references a public function
    function privateFunction() {
      publicFunction();
    }
    // Define publicFunction using a function expression // [!code focus:4]
    let publicFunction = () => { 
      console.log("publicFunction: original implementation");
    };
    
    // define a setter function for the publicFunction // [!code focus:4]
    function setPublicFunction(newPublicFunction) {
      publicFunction = newPublicFunction;
    };
    
    // define a getter function for the publicFunction // [!code focus:3]
    function getPublicFunction() {
      return publicFunction;
    }
    
    setTimeout(() => {
      console.log('-----------setTimeout-------------');
      privateFunction();
    }, 3000);
    
    export default {
      publicFunction,
      setPublicFunction, // [!code focus:3]
      getPublicFunction
    };
  ```

  ```js
    // moduleTwo.mjs
    
    import moduleOne from './moduleOne.mjs';
    
    // use the getter funciton to get the public function // [!code focus:2]
    let publicFunction = moduleOne.getPublicFunction();
    // logs the original message
    publicFunction();
    
    const newPublicFunction = function () { 
      console.log("publicFunction: redefined implementation");
    };
    // Use the setter function to set a new public function // [!code focus:2]
    moduleOne.setPublicFunction(newPublicFunction); 
    
    
    // Again, use the getter funciton to get the new public function  // [!code focus:2]
    publicFunction = moduleOne.getPublicFunction();
    // logs the new message
    publicFunction();
    
    // After two seconds the `setTimeout` function will call the privateFunction
    // which calls publicFunction, which will log the new message.
  ```

    <br/>

  Output:
  <img src="/images/blog/patterns/creational/module/solution_2.png" alt="Disadvantage #2" class="w-full">

</section>

<section>

    ## Wrapping Up
    The "Learning JavaScript Design Patterns" closes off the chapter with the following: 
    
    >"A disadvantage of this pattern is that if a private function refers to a public
    function, that public function can’t be overridden if a patch is necessary.
    This is because the private function will continue to refer to the private
    implementation, and the pattern doesn’t apply to public members, only to
    functions.
    
    > Public object members, which refer to private variables, are also subject to
    the no-patch rule."

    I couldn't make sense of the following: "Public object members, which refer to private variables, are also subject to
    the no-patch rule." and therefore I wasn't able to illustrate it within the code examples. If someone else understands
    this, please let me know.

    I found the language in the chapter slightly confusing, as someone else that I spoke with did too. The chapter uses the
    words "overriding" and "patching", and I inferred them to mean the same and used interchangably but decided to not use 
    them in my article because I found them confusing, as "overriding" is usually mentioned in the context of overriding 
    **class methods** and not methods of an object And "patching" doesn't seem to be a thing in the javascript world. I am sure 
    these words were was used in a general sense, but I've opted not to use them in my article. 

    If I am wrong about any of the code examples, please correct me. I enjoyed writing this article and learned a lot a lot from it. 
    Thank you for reading.

</section>

<section>

    ## Resources

    - "Learning JavaScript Design Patterns" Second Edition by Addy Osmani, specifically Chapter 7: 
      JavaScript Design Patterns.

</section>