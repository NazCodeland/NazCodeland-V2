---
title: Constructor Design Pattern
created: June 30th, 2024
updated: July 11th, 2024
description:
  The Constructor Design Pattern is a creational design pattern and it is automatically invoked every 
  time we instantiate a new instance of a class using the new operator. This method is responsible 
  for initializing the state of the newly created instance by assigning its initial properties and 
  methods. If the class is a subclass, meaning it inherits from a superclass, the constructor invokes 
  the superclass's constructor to ensure newly created instances are assigned the properties and methods 
  of the superclass.
tags: ['javascript']
categories: ['design patterns', 'oop']
---

<script lang="ts">
	import Link from '$lib/elements/Link.svelte';
</script>

<section>

  ## Explanation

	The Constructor Design Pattern is a creational design pattern and it is automatically invoked every 
  time we instantiate a new instance of a class using the **new** operator. This method is responsible 
  for initializing the state of the newly created instance by assigning its _initial_ properties and 
  methods. If the class is a subclass, meaning it inherits from a superclass, the constructor invokes 
  the superclass's constructor to ensure newly created instances are assigned the properties and methods 
  of the superclass.

</section>

<section>
	<Link href="https://en.wikipedia.org/wiki/Constructor_(object-oriented_programming)" linkText="Wikipedia article" block={true} /> says:

		> In class-based, object-oriented programming, a constructor (abbreviation: ctor) is a special type of
		function called to create an object. It prepares the new object for use, often accepting arguments that
		the constructor uses to set required member variables.

</section>


<section>

  ## Analogy

	We can think of a bicycle factory as an analogy for the constructor design pattern. A bicycle factory 
  probably uses a blueprint to ensure all bicycles have the same components, such as tires, chains, and 
  a gear shifting mechanism. This is similar to how a constructor method assigns initial properties and 
  methods to new instances. Just as the factory may produce some parts in-house and purchase others, a 
  subclass might initialize some properties and methods and invoke the superclass's constructor for 
  inheriting properties and methods.

</section>


<section>

  ## Code Example

  The non-blurred code is the focus of the current article, and the blurred code introduces topics for future articles.

  <p class="bg-primaryColor/15 text-canvas px-2 py-1 rounded-md">ES6 Syntax</p>

  
  ```js
    class Bicycle { 	// [!code focus:1]
      // Class fields are instance specific properties
      // I will cover class fields in another article
      model = 'regular bike';
      chain = 'standard chain';
      year = 2024;
      tires = 2;
  
      constructor(color, size) { 		// [!code focus:10]
        // Properties defined in the constructor are instance specific
        this.color = color;
        this.size = size;  
        // See 'Wrapping Up' for more on defining methods in the constructor
        this.someMethod = function () {
          // Do something
        };
      }
  
      // Methods defined within the class body are shared among all instances
      honk() {
        console.log('honk');
      }   
      gearShiftingMechanism() {
      	// Regular bike implementation
      }
    }

    // Instantiate a new instance of Bicycle class 	// [!code focus:2]
    const bicycle = new Bicycle('blue', 'large');

  ```

  <br/>


	`MountainBike` is a subclass of `Bicycle` and therefore it needs to invoke the 
	constructor of its superclass by using the `super` keyword and passing in the 
	required arguments.


  ```js
    class MountainBike extends Bicycle { 	// [!code focus:1]
      model = 'mountain bike';
      chain = 'advanced chain';
      terrainTypes = ['trail', 'downhill', 'cross-country'];


      constructor(color, size, terrainType) { 		
        // super needs to be invoked before using `this` keyword
        super(color, size);      // [!code focus:1]
        if (!this.terrainTypes.includes(terrainType)) {
          throw new Error('Invalid terrain type');
        } else {
          this.terrainType = terrainType;
        }
      } 			


      // Override the method defined in the superclass by
      // Adding a specific implementation for mountain bikes
      gearShiftingMechanism() {
     	  // Mountain bike implementation
      }
    } // [!code focus:1]

    // Instantiate a new instance of Bicycle class
    const mountainBike = new MountainBike('black', 'medium', 'trail'); 	// [!code focus:1]
  ```

</section>

<section>

  ## Constructors Before ES6

  Prior to ES6, the class syntax that we used above did not exist. The keywords `class`, `extends`, `super`, and the `constructor`
  method were not a thing. Instead, constructor functions, which by convention should start with a capital
  letter, were used to create objects (instances), and  the inheritance chain was setup by assigning the prototype of
  the constructor function to an object created from the prototype of another constructor function. This allowed failed lookup
  calls on instance methods or properties to be delegated to the prototype of the parent constructor function. To share methods
  between all instances of a constructor function, the method had to be defined on the prototype of the constructor function.
  Here is an example of the Bicycle and MountainBike classes using constructor functions:

  ```js
    function Bicycle(color, size){ 	// [!code focus:10]
      // Equivalent to instance specific properties
      this.modal = 'regular bike';
      this.chain = 'standard chain';
      this.year = 2024;
      this.tires = 2;
      this.color = color;
      this.size = size;
    }

    // Shared instance methods
    Bicycle.prototype.honk = function(){
      console.log('honk');
    }

    Bicycle.prototype.gearShiftingMechanism = function(){}

    var bicycle = new Bicycle('blue', 'large');
  ```

  
  ```js
    function MountainBike(color, size, terrainType){ // [!code focus:8]
      this.model = 'mountain bike';
      this.chain = 'advanced chain';
      this.terrainTypes = ['trail', 'downhill', 'cross-country'];
    
      // Equivalent to super(color, size);
      Bicycle.call(this, color, size)
    }

    // Setup the inheritance chain
    MountainBike.prototype = Object.create(Bicycle.prototype);
  
    // Reset the constructor property
    // Resetting the constructor is important for correctly 
    // identifying the constructor of an instance and for other reasons.
    MountainBike.prototype.constructor = MountainBike
  
    // Steps for defining methods on the prototype of MountainBike:
    // 1. Assign the prototype of MountainBike to a new object created
    //  from the Bicycle.prototype object.
    // 2. Reset the constructor property to point back to MountainBike.
    // 3. Define methods on the prototype of MountainBike.
    // Otherwise the methods/properties will be lost.
    MountainBike.prototype.gearShiftingMechanism = function(){
      // This method will override the method inherited from
      // the Bicycle prototype
    }

    var mountainBike = new MountainBike('black', 'medium', 'trail'); 	
  ```


</section>


<section>

	## Wrapping Up

	Some sources do not view the constructor as a design pattern but rather as a 
	method of a class for initializing properties and methods of a new instance. 
	Also, many definitions, just like mine, say that it is responsible for 
	initializing properties and methods. But I have not come across a use case for
	initializing methods within the constructor, and if we were to initialize a 
	method within the constructor, it would be unique for each instance and therefore 
	not a method in the sense of what a method means in OOP: a function on a class 
	that is shared between all instances of that class.

	But, as my mentor <Link href="https://github.com/ericchase" linkText="Chase"  /> 
	pointed out, <abbr title="Mozilla Developer Network">MDN</abbr> says, 
	`A property's value can be a function, in which case the property is known as a method.`
	He also pointed out that we developers only write the constructor method, but 
	behind the scenes, there is probably a lot more going on in the construction phase.
	So, therefore, there probably is a use case for initializing methods within the 
	constructor that I just don't know about due to my lack of knowledge.

	I've also asked <Link href="https://www.youtube.com/@jmagrippis" linkText="Jonny Magrippis"  />, 
	who is a great instructor, and even he says he hasn't seen a legit use case for it. 
	If you do know of a use case, please share!
</section>

